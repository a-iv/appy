'''This script allows to generate a product from a Appy application.'''

# ------------------------------------------------------------------------------
import sys, os.path
from optparse import OptionParser
from appy.gen.generator import GeneratorError
from appy.shared.utils import LinesCounter
import appy.version

# ------------------------------------------------------------------------------
ERROR_CODE = 1
VALID_PRODUCT_TYPES = ('zope', 'odt')
APP_NOT_FOUND = 'Application not found at %s.'
WRONG_NG_OF_ARGS = 'Wrong number of arguments.'
WRONG_OUTPUT_FOLDER = 'Output folder not found. Please create it first.'
PRODUCT_TYPE_ERROR = 'Wrong product type. Product type may be one of the ' \
                     'following: %s' % str(VALID_PRODUCT_TYPES)
C_OPTION = 'Removes from i18n files all labels that are not automatically ' \
           'generated from your gen-application. It can be useful during ' \
           'development, when you do lots of name changes (classes, ' \
           'attributes, states, transitions, etc): in this case, the Appy ' \
           'i18n label generation machinery produces lots of labels that ' \
           'then become obsolete.'
S_OPTION = 'Sorts all i18n labels. If you use this option, among the ' \
           'generated i18n files, you will find first all labels ' \
           'that are automatically generated by appy.gen, in some logical ' \
           'order (ie: field-related labels appear together, in the order ' \
           'they are declared in the gen-class). Then, if you have added ' \
           'labels manually, they will appear afterwards. Sorting labels ' \
           'may not be desired under development. Indeed, when no sorting ' \
           'occurs, every time you add or modify a field, class, state, etc, ' \
           'newly generated labels will all appear together at the end of ' \
           'the file; so it will be easy to translate them all. When sorting ' \
           'occurs, those elements may be spread at different places in the ' \
           'i18n file. When the development is finished, it may be a good ' \
           'idea to sort the labels to get a clean and logically ordered ' \
           'set of translation files.'

class GeneratorScript:
    '''usage: %prog [options] app productType outputFolder

       "app"          is the path to your Appy application, which must be a
                      Python package (= a folder containing a file named
                      __init__.py). Your app may reside anywhere, but needs to
                      be accessible by Zope. Typically, it may be or symlinked
                      in <yourZopeInstance>/lib/python, but not within the
                      generated product, stored or symlinked in
                      <yourZopeInstance>/Products.

       "productType"  is the kind of product you want to generate. "zope" is
                      the only available production-ready target.
                      "odt" is experimental.
                      
       "outputFolder" is the folder where the Zope product will be generated.
                      For example, if you develop your application in
                      /home/gdy/MyProject/MyProject, you typically specify
                      "/home/gdy/MyProject/zope" as outputFolder.
    '''

    def generateProduct(self, options, application, productType, outputFolder):
        if productType == 'odt':
            exec 'from appy.gen.odt.generator import Generator'
        else:
            from appy.gen.generator import ZopeGenerator as Generator
        Generator(application, outputFolder, options).run()

    def manageArgs(self, parser, options, args):
        # Check number of args
        if len(args) != 3:
            print WRONG_NG_OF_ARGS
            parser.print_help()
            sys.exit(ERROR_CODE)
        # Check productType
        if args[1] not in VALID_PRODUCT_TYPES:
            print PRODUCT_TYPE_ERROR
            sys.exit(ERROR_CODE)
        # Check existence of application
        if not os.path.exists(args[0]):
            print APP_NOT_FOUND % args[0]
            sys.exit(ERROR_CODE)
        # Check existence of outputFolder basic type
        if not os.path.exists(args[2]):
            print WRONG_OUTPUT_FOLDER
            sys.exit(ERROR_CODE)
        # Convert all paths in absolute paths
        for i in (0,2):
            args[i] = os.path.abspath(args[i])
    def run(self):
        optParser = OptionParser(usage=GeneratorScript.__doc__)
        optParser.add_option("-c", "--i18n-clean", action='store_true',
            dest='i18nClean', default=False, help=C_OPTION)
        optParser.add_option("-s", "--i18n-sort", action='store_true',
            dest='i18nSort', default=False, help=S_OPTION)
        (options, args) = optParser.parse_args()
        try:
            self.manageArgs(optParser, options, args)
            print 'Appy version:', appy.version.verbose
            print 'Generating %s product in %s...' % (args[1], args[2])
            self.generateProduct(options, *args)
            # Give the user some statistics about its code
            LinesCounter(args[0]).run()
        except GeneratorError, ge:
            sys.stderr.write(str(ge))
            sys.stderr.write('\n')
            optParser.print_help()
            sys.exit(ERROR_CODE)

# ------------------------------------------------------------------------------
if __name__ == '__main__':
    GeneratorScript().run()
# ------------------------------------------------------------------------------
